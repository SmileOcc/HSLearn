举例V1状态装饰器有什么？是做什么的？
在鸿蒙开发中，状态装饰器是 ArkTS 语言里用于管理组件状态的关键工具，在早期版本（V1）中有以下常见的状态装饰器及其作用，以下是一个完整的鸿蒙开发示例，展示了如何使用 @State、@Prop、@Link、@Provide 和 @Consume 这些 V1 状态装饰器：

V2状态装饰器主要解决了什么问题？都有什么？举几个例子即可
自从api7开始，一直到api10。V1的实际使用中，开发人员发现@Observed和@ObjectLink 监听实现多层级嵌套对象的更新的方案，太过于臃肿。

当需要监听处理更新的多层级对象是七八层，就需要配套创建七八层的ObjectLink，代码太过于冗余。

三、V2状态管理装饰器的优点和不足
V2的优点

具备深度观察、属性级更新。
组件中明确状态变量的输入与输出，利于组件化
状态变量能独立于UI存在，同一个数据被多个视图代理时，在其中一个视图的更改会通知其他视图更新
V2的不足

复杂对象时V1的@State能够观察复杂对象的第一层属性变化，但V2的@Local无法观察对象内部变化。为了解决这个问题，需要在类上添加@ObservedV2，并在需要观察的属性上添加@Trace。这样，框架就能追踪对象内部的属性变化。相对于V1稍微麻烦些。
animateTo暂不支持直接在状态管理V2中使用


正因为以上的缺陷，V2状态管理装饰器由此诞生。但是目前开发进程还有堵塞点，官方建议慎重使用V2。


 HAR和HSP分别是什么？区别是什么？
纯血鸿蒙中，HAR 是静态资源共享包，用于存放图片、配置文件等不频繁变更的内容；HSP 是用于底层及应用层动态更新文件的包。二者区别在于存储内容和更新频率不同 。


应用切到后台后，如何保证任务继续进行？
在鸿蒙应用开发中，当应用切到后台后，系统会对应用进行一定的管控，以优化资源利用和用户体验。为保证任务在后台继续进行，可采用以下方式：

申请后台任务权限，需要配置权限ohos.permission.KEEP_BACKGROUND_RUNNING：



11. UIAbility和Page以及组件的生命周期函数
UIAbility 有 onCreate、onWindowStageCreate 等生命周期函数用于自身创建、窗口阶段创建等阶段。
Page 有 onPageShow、onPageHide 等函数处理页面显示与隐藏等情况，aboutToAppear等。
组件则有自身从创建到销毁过程中的如 init、build、delete 等生命周期函数来管理其状态和渲染等操作。

11. router和Navigaiton的区别是什么？
在鸿蒙开发里，Router 和 Navigation 虽都用于页面导航，但存在明显差异。Router 功能基础，侧重于简单的页面切换，支持通过 URL 跳转，页面间数据传递需手动处理，适用于页面结构和导航逻辑简单的场景，因功能轻量，在简单场景下性能开销小、导航速度快，使用时主要调用 Router.pushUrl 方法；而 Navigation 功能更丰富，支持栈管理和便捷的返回数据处理，适合复杂导航及需处理返回数据的场景，不过因管理页面栈等操作性能开销稍大。


12. 数据临时和持久存储技术方案是什么？
数据临时存储可使用内存变量，在程序运行期间保存数据，应用关闭或进程被杀时数据丢失；还能利用函数内部的局部变量实现临时存储。而数据持久存储方面，可采用 LocalStorage，它能在本地存储数据，即使应用关闭或进程被杀，数据依然保留，存储容量有限，约 5 - 10 兆；APP Storage 也是常用方案，它存储无限制，数据存于沙箱，仅卸载应用时数据才被清除；此外，还能借助数据库，如关系型数据库或轻量级的文件数据库，来高效管理和持久存储结构化数据，满足复杂数据存储和查询需求。


一、ForEach，LazyForEach，Repeat三者关系
在鸿蒙中列表组件循环渲染的实现，一般都是通过ForEach来配合列表容器组件实现，例如List。也可以直接ForEach去创建多个相同的View。

以下代码，是个简单的ForEach使用。在list组件中通过包裹ForEach来循环渲染创建子组件。数据通过传入数组对象的形式，批量一次性循环渲染更新完数据。

需要注意的是，在ForEach组件进行非首次渲染时，它会检查新生成的键值是否在上次渲染中已经存在。如果键值不存在，则会创建一个新的组件；如果键值存在，则不会创建新的组件，而是直接渲染该键值所对应的组件。
